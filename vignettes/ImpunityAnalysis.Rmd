---
title: "Impunity Analysis - Simplex Regression"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Impunity Analysis - Simplex Regression}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This vignette demonstrates the use of the `SimplexRegressionAMM` package to model impunity data across countries. 
We explore the advantages of parametric mean link functions (plogit1 and plogit2) compared to traditional fixed mean link functions, 
and provide comprehensive model diagnostics.

The impunity dataset contains information about various socioeconomic and political indicators in 119 countries, with the response variable measuring levels of impunity (a bounded variable in the open interval (0,1)).

## Loading the Data
```{r setup}
library(SimplexRegressionAMM)
data("impunity_dataset")
data_imp <- impunity_dataset
n <- nrow(data_imp)
```

### Data Overview

The dataset includes 119 observations and nine explanatory variables reflecting economic, institutional, and social aspects of each country:

- Economic Freedom Index (2022)
- Gini Index (2015)
- Health Expenditure as % of GDP (2020)
- Human Development Index (2019)
- GDP per capita (2018)
- Press Freedom Index (2023)
- Quality of Democracy Index (2020)
- Dummy variable for Nordic countries

```{r data-structure}
str(data_imp)
```

A preview of the first few observations:

```{r data-head}
head(data_imp)
```

### Descriptive Statistics for the Response Variable

The response variable `Impunity` is bounded in the open interval (0,1) and consists of Impunity Index scores for 119 countries in 2023, as described in Cribari-Neto and Santos (2024).  

The Impunity Index is defined as one minus the Rule of Law Index published by the World Justice Project (WJP). Higher values correspond to weaker rule of law and higher levels of impunity.  

According to the WJP, the Rule of Law Index is built upon eight dimensions: constraints on government powers, absence of corruption, open government, protection of fundamental rights, order and security, regulatory enforcement, civil justice, and criminal justice.

Let's examine the distribution of the response variable:

```{r descriptive-stats}
# Summary statistics
summary(data_imp$Impunity)

# Additional descriptive measures
cat("\nDescriptive Statistics for Impunity:\n")
cat("Std Dev:  ", round(sd(data_imp$Impunity), 4), "\n")
cat("Skewness: ", round(moments::skewness(data_imp$Impunity), 4), "\n")
cat("Kurtosis: ", round(moments::kurtosis(data_imp$Impunity), 4), "\n")
```

# Models with Parametric Mean Link Functions

One of the main features of simplex regression with a parametric mean link function is its ability to employ link functions that adapt to the structure of the data. These functions incorporate an additional parameter, \eqn{\lambda}, which is estimated from the data, providing greater flexibility compared to fixed mean link functions.

We estimated simplex regression models with parametric mean link functions `plogit1` and `plogit2`, including all eight covariates, selected power transformations, and interaction terms.  

Predictor selection was guided by half-normal residual plots with simulated envelopes, pseudo-\eqn{R^2}, and information criteria (AIC, SIC, HQIC).

## Model 1: plogit1 Parametric Mean Link Function

The first model uses the `plogit1` parametric mean link function and includes interactions between predictors:
  
```{r model-plogit1}
simplex_par1 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    EconomicFreedom + HealthSpending + Democracy,
  data = data_imp,
  link.mu = "plogit1", 
  link.sigma2 = "log"
)

summary(simplex_par1)
```

**Model interpretation:**
- The mean structure includes transformed and interacted predictors;
- The dispersion structure is modeled as a function of EconomicFreedom, HealthSpending, and Democracy;
- The lambda parameter in plogit1 mean link function is estimated from the data.

### Half-Normal Plot with simulated envelopes for Model 1

We use weighted residual (Espinheira and Silva, 2020) for Half-Normal plot with simulated envelopes.

```{r diagnostic-par1, fig.cap="Half-normal plot with simulated envelope for Model 1"}
hnp.simplexreg(simplex_par1, type = "weighted", seed = 2008)
```

## Model 2: plogit2 Parametric Mean Link Function

The second model uses the `plogit2` parametric mean link function with a different dispersion structure:
  
```{r model-plogit2}
simplex_par2 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    I(Democracy*Press) + I(HealthSpending^1.6),
  data = data_imp,
  link.mu = "plogit2", 
  link.sigma2 = "log"
)

summary(simplex_par2)
```

### Half-Normal Plot with simulated envelopes for Model 2

```{r diagnostic-par2, fig.cap="Half-normal plot with simulated envelope for Model 2"}
hnp.simplexreg(simplex_par2, type = "weighted", seed = 2008)
```

### Model Selection: Parametric Mean Link Functions

We use the penalized Scout Score (SS) criterion to select between models with parametric mean link functions:
  
```{r scout-score}
ss.simplexreg(simplex_par1, simplex_par2, kappa = 0.1)
```

We can also examine penalized information criteria:
  
```{r penalized-ic}
penalized_ic(simplex_par1)
penalized_ic(simplex_par2)
```

# Models with Fixed Mean Link Functions

For comparison, we also fit simplex regression models using traditional fixed mean link functions (logit, probit, log-log, complementary log-log, and cauchit).  

These models help assess whether the flexibility provided by parametric mean link functions leads to better fit.

## Model with log-log Mean Link Function

```{r model-loglog}
simplex1 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    EconomicFreedom + HealthSpending + Democracy, 
  data = data_imp,  
  link.mu = "loglog", 
  link.sigma2 = "log"
)

summary(simplex1)
```

## Model with logit Mean Link Function

```{r model-logit}
simplex2 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    EconomicFreedom + HealthSpending + Democracy, 
  data = data_imp,  
  link.mu = "logit", 
  link.sigma2 = "log"
)

summary(simplex2)
```

## Model with probit Mean Link Function

```{r model-probit}
simplex3 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    EconomicFreedom + HealthSpending + Democracy,  
  data = data_imp, 
  link.mu = "probit", 
  link.sigma2 = "log"
)

summary(simplex3)
```

## Model with complementary log-log Mean Link Function

```{r model-cloglog}
simplex4 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    HealthSpending + I(Democracy^0.4), 
  data = data_imp, 
  link.mu = "cloglog", 
  link.sigma2 = "log"
)

summary(simplex4)
```

## Model with cauchit Mean Link Function

```{r model-cauchit}
simplex5 <- simplexreg(
  Impunity ~ EconomicFreedom + I(GDP^1.15) + I(HDI*HealthSpending) + 
    I(Democracy*Press) + dnordic |
    HealthSpending + I(Democracy^0.4), 
  data = data_imp,  
  link.mu = "cauchit", 
  link.sigma2 = "log"
)

summary(simplex5)
```

## Model Selection: Comparing All Models

We now compare the model with parametric mean link function (`plogit1`) to models using fixed mean link functions. For this comparison, we use the original Scout Score (`kappa = 0`).
  
```{r model-selection-all}
ss.simplexreg(simplex_par1, simplex1, simplex2, simplex3, simplex4, simplex5, 
              kappa = 0)
```

Direct comparison between the best parametric mean link function model and best fixed mean link model:
  
```{r model-selection-best}
ss.simplexreg(simplex_par1, simplex1, kappa = 0)
```

The results indicate that `simplex_par1` (with plogit1 parametric mean link function) provides the best fit.

## Testing lambda = 1

We can test whether the estimated lambda parameter is significantly different from 1. If lambda equals 1, the plogit1 parametric mean link function reduces to the logit fixed mean link function.
  
```{r test-lambda}
scoretest.simplexreg(simplex2, link = "plogit1")
```

The null hypothesis H₀: λ = 1 (which corresponds to the logit mean link) was rejected at the 1% significance level (p = 0.0011), confirming the relevance of using a parametric mean link function specification. 

# Model Diagnostics

We now perform comprehensive diagnostics on the selected model (`simplex_par1`). We use quantile residuals, which should approximately follow a standard normal distribution under correct model specification.

## Residual Plots

```{r residual-plots, fig.cap="Diagnostic plots for the selected model"}
# Residuals vs observation indices
plot(simplex_par1, which = 1, type = "quantile")

# Residuals vs fitted values
plot(simplex_par1, which = 2, type = "quantile")

# Residuals vs predicted values
plot(simplex_par1, which = 3, type = "quantile")

# Predicted vs fitted values
plot(simplex_par1, which = 4, type = "quantile")

# Q-Q plot
plot(simplex_par1, which = 5, type = "quantile")

# Worm plot
plot(simplex_par1, which = 6, type = "quantile")

# Cook's distance vs observation indices
plot(simplex_par1, which = 7, type = "quantile")
```

### Normality Test for Quantile Residuals

We test whether the quantile residuals follow a normal distribution:

```{r normality-test}
tseries::jarque.bera.test(residuals(simplex_par1, type = "quantile"))
```

## Local Influence Analysis

Local influence analysis helps identify observations that have disproportionate impact on parameter estimates. We consider two perturbation schemes:

### Case-Weight Perturbation Scheme

```{r influence-case-weight, fig.cap="Local influence: Case-weight perturbation"}
influences_cw <- local.influence_simplexreg(simplex_par1, 
                                            scheme = "case.weight")$Ci.beta
names(influences_cw) <- 1:n

plot(influences_cw, 
     xlab = "Observation index", 
     ylab = expression(C[i*";"*beta]),  
     pch = 16, 
     cex = 0.8)
abline(h = 2*mean(influences_cw), lty = 2, col = "red")

# Identify influential observations
influential_cw <- which(influences_cw > 2*mean(influences_cw))
if(length(influential_cw) > 0) {
  text(influential_cw, influences_cw[influential_cw], 
       labels = influential_cw, 
       pos = 3, cex = 0.7, col = "blue")
}

cat("\nNumber of influential observations (case-weight):", 
    sum(influences_cw > 2*mean(influences_cw)), "\n")
```

### Response Perturbation Scheme

```{r influence-response, fig.cap="Local influence: Response perturbation"}
influences_resp <- local.influence_simplexreg(simplex_par1, 
                                              scheme = "response")$Ci.beta
names(influences_resp) <- 1:n

plot(influences_resp, 
     xlab = "Observation index", 
     ylab = expression(C[i*";"*beta]),  
     pch = 16, 
     cex = 0.8)
abline(h = 2*mean(influences_resp), lty = 2, col = "red")

# Identify influential observations
influential_resp <- which(influences_resp > 2*mean(influences_resp))
if(length(influential_resp) > 0) {
  text(influential_resp, influences_resp[influential_resp], 
       labels = influential_resp, 
       pos = 3, cex = 0.7, col = "blue")
}

cat("\nNumber of influential observations (response):", 
    sum(influences_resp > 2*mean(influences_resp)), "\n")
```

# Visualizing Mean Link Functions

### Comparing Mean Link Functions: Inverse Links

This plot shows how different link functions map linear predictors to the mean response:
  
```{r link-comparison, fig.cap="Comparison of inverse link functions"}
eta <- seq(from = -2, to = 5.5, length.out = 250)

# Compute inverse links
mu_plogit1 <- parametric_mean_link_inv(eta, simplex_par1$coefficients$lambda, "plogit1")
mu_probit <- fixed_mean_link_inv(eta, "probit")
mu_loglog <- fixed_mean_link_inv(eta, "loglog")

# Plot
matplot(eta, cbind(mu_plogit1, mu_probit), 
        type = "l", 
        lwd = 2, 
        lty = c(1, 2), 
        col = c("black", "blue"), 
        ylab = expression(mu[i]), 
        xlab = expression(eta[1*i]),
        main = "Inverse Link Functions")

legend("bottomright", 
       legend = c(
         bquote("plogit1 (" * lambda == .(round(simplex_par1$coefficients$lambda, 4)) * ")"), 
         "probit"
       ), 
       lty = c(1, 2), 
       cex = 0.7, 
       col = c("black", "blue"),
       lwd = 2, 
       bty = "n")
```

# Conclusion

This analysis demonstrates several key features of the `SimplexRegressionAMM` package:
  
1. **Parametric mean link functions** (plogit1, plogit2) provide flexibility by estimating the link parameter from the data
2. **Model selection** using Scout Score effectively identifies the best-fitting model
3. **Comprehensive diagnostics** including residual analysis, influence measures, and specification tests help validate model adequacy
4. The **selected model** (simplex_par1 with plogit1 parametric mean link function) shows good fit and appropriate residual behavior

The parametric mean link function approach offers advantages over fixed mean link functions when the optimal transformation is unknown a priori, as demonstrated by the superior performance of `simplex_par1` in this application.

# References

F. Cribari-Neto, M. A. F. L. Santos, An empirical analysis of worldwide impunity, Humanities and Social Sciences Communications 11 (2024) 1285. https://doi.org/10.1057/s41599-024-03803-x

P. L. Espinheira, A. O. Silva, Residual and influence analysis to a general class of simplex regression, TEST 29 (2020) 523–552. https://doi.org/10.1007/s11749-019-00665-3

```
